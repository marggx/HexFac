This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-09T00:46:02.302Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  core/
    render/
      canvas.ts
      html.ts
    utils/
      arrayUtils.ts
      browserUtils.ts
      numberUtils.ts
    dpi_manager.ts
    i18n.ts
    logging.ts
    save.ts
    settings.ts
  game/
    core/
      events.ts
      game.ts
      layout.ts
      loadingScreen.ts
      ui.ts
    models/
      buildings/
        base.ts
        furnace.ts
      items/
        coal.ts
        copper.ts
        copperOre.ts
        iron.ts
        ironOre.ts
        stone.ts
        wood.ts
      recipes/
        ironOreToIron.ts
        wood.ts
        woodToCoal.ts
      building.ts
      hex.ts
      hexagonMap.ts
      item.ts
      recipe.ts
      vector.ts
    const.ts
  main.css
  main.ts
  vite-env.d.ts
.editorconfig
.gitignore
index.html
package.json
postcss.config.js
tailwind.config.js
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/core/render/canvas.ts
================
import { Vector2 } from "../../game/models/vector";

const sqrt3 = Math.sqrt(3);

const canvas: HTMLCanvasElement = <HTMLCanvasElement>document.getElementById("game")!;
const ctx: CanvasRenderingContext2D = canvas.getContext("2d")!;
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = "high";

resizeCanvas(canvas, ctx);

addEventListener("resize", () => resizeCanvas(canvas, ctx));

export function resizeCanvas(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {
    const canvasWidth = innerWidth;
    const canvasHeight = innerHeight;

    canvas.width = canvasWidth * window.devicePixelRatio;
    canvas.height = canvasHeight * window.devicePixelRatio;
    canvas.style.width = canvasWidth + "px";
    canvas.style.height = canvasHeight + "px";

    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
}

export function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

let imgs = [
    "./../../../src/assets/img/grass_12.png",
    "./../../../src/assets/img/grass_13.png",
    "./../../../src/assets/img/grass_14.png",
    "./../../../src/assets/img/grass_15.png",
    "./../../../src/assets/img/grass_16.png",
    "./../../../src/assets/img/dirt_13.png",
    "./../../../src/assets/img/dirt_14.png",
    "./../../../src/assets/img/dirt_15.png",
    "./../../../src/assets/img/dirt_16.png",
    "./../../../src/assets/img/dirt_17.png",
];
let imgr = [];
for (let i = 0; i < imgs.length; i++) {
    let img = new Image();
    img.src = imgs[i];
    imgr.push(img);
}

export function drawPolygon(
    points: Vector2[],
    fillStyle: string | null,
    strokeStyle: string | null,
    lineWidth: number
) {
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
    }
    ctx.closePath();
    if (fillStyle !== null) {
        ctx.fillStyle = fillStyle;
        ctx.fill();
    }
    ctx.lineWidth = lineWidth;
    if (strokeStyle !== null) {
        ctx.strokeStyle = strokeStyle;
    }

    ctx.stroke();
}

export function drawText(text: string) {
    ctx.font = "30px Arial";
    ctx.fillText(text, 10, 50);
}

export function drawImage(point: Vector2, x: number, y: number, img: string) {
    let imgn = imgr[imgs.indexOf(img)];
    if (!imgn) return;
    ctx.drawImage(imgn, point.x - (sqrt3 * x) / 2, point.y - (2 * y) / 2, sqrt3 * x, 2 * y);
}

export function drawLines(lines: [Vector2, Vector2][], strokeStyle: string, lineWidth: number) {
    ctx.beginPath();
    for (let i = 0; i < lines.length; i++) {
        ctx.moveTo(lines[i][0].x, lines[i][0].y);
        ctx.lineTo(lines[i][1].x, lines[i][1].y);
    }
    ctx.fillStyle = "blue";
    ctx.fill();
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = strokeStyle;
    ctx.stroke();
}

export function writeText(text: string, point: Vector2) {
    ctx.font = "30px Arial";
    ctx.fillText(text, point.x, point.y);
}

================
File: src/core/render/html.ts
================
export const upArrow: string = "↗︎";
export const downArrow: string = "↘︎";

export function find(selector: string) {
    let el = document.querySelector(selector);
    if (el === null) {
        throw new Error("Element not found");
    }
    return el;
}

export function findAll(selector: string) {
    let els = document.querySelectorAll(selector);
    if (els === null) {
        throw new Error("Elements not found");
    }
    return els;
}

export function create(tag: string, className: string | null = null) {
    let el = document.createElement(tag);
    if (className !== null) {
        el.className = className;
    }
    return el;
}

export function createText(text: string) {
    return document.createTextNode(text);
}

export function createSvg(tag: string, className: string | null = null) {
    let el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    if (className !== null) {
        el.setAttribute("class", className);
    }
    return el;
}

export function createDivider(text: string | null = null) {
    let divider = create("div", "divider");
    if (text !== null) {
        divider.appendChild(createText(text));
    }
    return divider;
}

================
File: src/core/utils/arrayUtils.ts
================
export function randomChoice(arr: Array<any>) {
    return arr[Math.floor(Math.random() * arr.length)];
}

export function fastArrayDelete(arr: Array<any>, index: number) {
    if (index < 0 || index >= arr.length) {
        return;
    }

    if (index !== arr.length - 1) {
        const last = arr[arr.length - 1];
        arr[index] = last;
    }
    arr.length -= 1;
}

export function fastArrayDeleteValue(arr: Array<any>, value: any) {
    if (arr == null) {
        return;
    }
    const index = arr.indexOf(value);
    if (index < 0) {
        return;
    }
    fastArrayDelete(arr, index);
}

export function arrayDeleteValue(arr: Array<any>, value: any) {
    if (arr == null) {
        return;
    }
    const index = arr.indexOf(value);
    if (index < 0) {
        return;
    }
    arr.splice(index, 1);
}

================
File: src/core/utils/browserUtils.ts
================
export function timeoutPromise(promise: Promise<any>, timeout: number = 30000) {
    return Promise.race([
        new Promise((_resolve, reject) => {
            setTimeout(() => reject("timeout " + timeout + " ms exceeded"), timeout);
        }),
        promise,
    ]);
}

export function waitOneFrame() {
    return new Promise(function (resolve) {
        window.requestAnimationFrame(function () {
            window.requestAnimationFrame(function () {
                resolve(true);
            });
        });
    });
}

export function isBrowserSupported(): boolean {
    return (
        typeof window !== "undefined" &&
        typeof window.requestAnimationFrame !== "undefined" &&
        typeof window.localStorage !== "undefined" &&
        typeof window.Worker !== "undefined" &&
        typeof window.Blob !== "undefined" &&
        typeof window.URL !== "undefined"
    );
}

export function generateFileDownload(filename: string, text: string) {
    var element = document.createElement("a");
    element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
    element.setAttribute("download", filename);

    element.style.display = "none";
    document.body.appendChild(element);

    element.click();
    document.body.removeChild(element);
}

export function startFileChoose(acceptedType: string = ".bin") {
    var input = document.createElement("input");
    input.type = "file";
    input.accept = acceptedType;

    return new Promise((resolve) => {
        input.onchange = (_) => resolve(input.files ? input.files[0] : null);
        input.click();
    });
}

================
File: src/core/utils/numberUtils.ts
================
export function ranMinMax(min: number, max: number): number {
    return Math.floor(Math.random() * (max - min + 1) + min);
}

export function subtractWithWrapAround(num1: number, num2: number, max: number): number {
    let result = num1 - num2;
    if (result < 0) {
        result = max + result;
    }
    return result;
}

export function safeModulo(n: number, m: number): number {
    return ((n % m) + m) % m;
}

export function smoothPulse(time: number): number {
    return Math.sin(time * 4) * 0.5 + 0.5;
}

export function roundToDigit(n: number, digits: number): number {
    const factor = Math.pow(10, digits);
    return Math.round(n * factor) / factor;
}

export function floorToDigit(n: number, digits: number): number {
    const factor = Math.pow(10, digits);
    return Math.floor(n * factor) / factor;
}

export function lerp(a: number, b: number, x: number) {
    return a * (1 - x) + b * x;
}

export function clamp(v: number, min: number = 0, max: number = 1) {
    return Math.max(min, Math.min(max, v));
}

export function round1DigitLocalized(speed: number, separator: string = ","): string {
    return roundToDigit(speed, 1).toString().replace(".", separator);
}

export function isPositive(n: number): boolean {
    return n > 0;
}

================
File: src/core/dpi_manager.ts
================
import { roundToDigit } from "./utils/numberUtils";

export function getDeviceDPI(): number {
    return window.devicePixelRatio || 1;
}

export function smoothenDpi(dpi: number): number {
    if (dpi < 0.05) {
        return 0.05;
    } else if (dpi < 0.2) {
        return roundToDigit(Math.round(dpi / 0.04) * 0.04, 2);
    } else if (dpi < 1) {
        return roundToDigit(Math.round(dpi / 0.1) * 0.1, 1);
    } else if (dpi < 4) {
        return roundToDigit(Math.round(dpi / 0.5) * 0.5, 1);
    } else {
        return 4;
    }
}

export function prepareHighDPIContext(context: CanvasRenderingContext2D, smooth: boolean = true) {
    const dpi = getDeviceDPI();
    context.scale(dpi, dpi);

    if (smooth) {
        context.imageSmoothingEnabled = true;
        // @ts-ignore
        context.webkitImageSmoothingEnabled = true;
        context.imageSmoothingQuality =  'low';
    } else {
        context.imageSmoothingEnabled = false;
        // @ts-ignore
        context.webkitImageSmoothingEnabled = false;
    }
}

export function resizeHighDPICanvas(canvas: HTMLCanvasElement, w: number, h: number, smooth: boolean = true) {
    const dpi = getDeviceDPI();

    const wNumber = Math.floor(w);
    const hNumber = Math.floor(h);

    const targetW = Math.floor(wNumber * dpi);
    const targetH = Math.floor(hNumber * dpi);

    if (targetW !== canvas.width || targetH !== canvas.height) {
        // console.log("Resize Canvas from", canvas.width, canvas.height, "to", targetW, targetH)
        canvas.width = targetW;
        canvas.height = targetH;
        canvas.style.width = wNumber + "px";
        canvas.style.height = hNumber + "px";
        prepareHighDPIContext(canvas.getContext("2d")!, smooth);
    }
}

export function resizeCanvas(canvas: HTMLCanvasElement, w: number, h: number, setStyle: boolean = true) {
    const actualW = Math.ceil(w);
    const actualH = Math.ceil(h);
    if (actualW !== canvas.width || actualH !== canvas.height) {
        canvas.width = actualW;
        canvas.height = actualH;
        if (setStyle) {
            canvas.style.width = actualW + "px";
            canvas.style.height = actualH + "px";
        }
    }
}

export function resizeCanvasAndClear(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, w: number, h: number) {
    const actualW = Math.ceil(w);
    const actualH = Math.ceil(h);
    if (actualW !== canvas.width || actualH !== canvas.height) {
        canvas.width = actualW;
        canvas.height = actualH;
        canvas.style.width = actualW + "px";
        canvas.style.height = actualH + "px";
    } else {
        context.clearRect(0, 0, actualW, actualH);
    }
}

================
File: src/core/i18n.ts
================
import { getSetting, setSettings } from "./settings";

export let translation: any = {};

export function getLanguage(): string {
    let lang = getSetting("language");
    if (lang) return lang;

    // @ts-ignore
    lang = navigator.languages ? navigator.languages[0] : navigator.language || navigator.userLanguage;

    if (lang) {
        lang = lang.split("-")[0];
    } else {
        lang = "en";
    }

    setSettings({ key: "language", value: lang });
    loadTranslation(lang);
    return lang;
}

export function i18n(key: string): string {
    if (!translation) return key;
    if (translation[key]) {
        return translation[key];
    }
    return key;
}

export async function loadTranslation(lang: string): Promise<any> {
    if (translation) return;

    translation = await fetch(`./assets/translations/${lang}.json`);
    translation = await translation.json();

    return translation;
}

================
File: src/core/logging.ts
================
const timestamp = "⏱ %c" + (Math.floor(performance.now()) + "").padEnd(6, " ") + "";

================
File: src/core/save.ts
================
export function saveObject(key: string, object: any): void {
    const objectString = JSON.stringify(object);

    localStorage.setItem(key, btoa(encodeURIComponent(objectString)));
}

export function loadObject(key: string): any {
    if (!localStorage.getItem(key)) {
        return undefined;
    }
    const objectString = decodeURIComponent(atob(localStorage.getItem(key)!));

    return JSON.parse(objectString);
}

================
File: src/core/settings.ts
================
import { defaultSettings } from "../game/const";
import { loadObject, saveObject } from "./save";

export let settings: any = defaultSettings;

export function loadSettings(): any {
    let loadedSettings = loadObject("settings");
    if (loadedSettings) {
        settings = loadedSettings;
        return settings;
    }

    return settings;
}

export function setSettings(setting: { key: string; value: any }): void {
    settings[setting.key] = setting.value;
    saveObject("settings", settings);
}

export function saveSettings(saveSettings?: any): void {
    if (saveSettings) {
        settings = saveSettings;
    }
    saveObject("settings", settings);
}

export function getSetting(key: string): any {
    if (key.includes(".")) {
        const keys = key.split(".");
        let value = settings;
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (value[key] === undefined) {
                return undefined;
            }
            value = value[key];
        }
        return value;
    }

    return settings[key];
}

================
File: src/game/core/events.ts
================
import { Vector2 } from "../models/vector";
import Game from "./game";

export function initialize(args: { game: Game }) {
    const { game } = args;

    game.canvas.addEventListener("pointerup", (e) => game.tapUp({ x: e.clientX, y: e.clientY }));

    game.canvas.addEventListener("pointerdown", (e) => game.tapDown({ x: e.clientX, y: e.clientY }));

    game.canvas.addEventListener("pointermove", (e) => {
        game.tapMove({ x: e.movementX, y: e.movementY });
    });

    game.canvas.addEventListener("wheel", (e) => game.zoom(new Vector2((e.deltaY * -1) / 50, (e.deltaY * -1) / 50)));

    document.addEventListener("keydown", (e) => {
        if (e.ctrlKey) {
            game.layout.reset();
        }
    });
}

================
File: src/game/core/game.ts
================
import { loadObject, saveObject } from "../../core/save";
import { getSetting, loadSettings } from "../../core/settings";
import { Building } from "../models/building";
import Hex from "../models/hex";
import HexagonMap from "../models/hexagonMap";
import { Vector2, Vector2Attributes } from "../models/vector";
import { clearCanvas, drawLines, drawPolygon, resizeCanvas } from "./../../core/render/canvas";
import { initialize } from "./../../game/core/events";
import Layout, { orientation } from "./layout";
import LoadingScreen from "./loadingScreen";
import { setStorageDisplayFromItemMap, uiInitialize, updateStorageDispaly } from "./ui";

const FPS: number = 59;
const FPSInterval: number = 1000 / FPS;
const UPS: number = 10;
const UPSInterval: number = 1000 / UPS;
const UIPS: number = 4;
const UIPSInterval: number = 1000 / UIPS;

export default class Game {
    public canvas: HTMLCanvasElement = document.querySelector<HTMLCanvasElement>("#game")!;
    public ctx: CanvasRenderingContext2D = this.canvas.getContext("2d")!;
    public layout: Layout;
    private hexMap = new HexagonMap(105);
    private FPSOldTimeStamp: number = 0;
    private UPSOldTimeStamp: number = 0;
    private UIPSOldTimeStamp: number = 0;
    private tapedHex: Building | undefined = undefined;
    private highlightedHex: Hex | undefined = undefined;
    private tap: DOMHighResTimeStamp = 0;

    constructor() {
        let loading = new LoadingScreen(15);

        loadSettings();
        loading.stepLoadingScreen(5, "Loading settings");
        this.layout = new Layout(
            orientation,
            new Vector2(20, 20),
            getSetting("layout.maxSize"),
            getSetting("layout.minSize")
        );

        loading.stepLoadingScreen(1, "Layout");

        uiInitialize();

        loading.stepLoadingScreen(1, "noise");

        initialize({ game: this });

        loading.stepLoadingScreen(15, "start");

        this.init();
    }

    private init() {
        resizeCanvas(
            document.querySelector<HTMLCanvasElement>("#game")!,
            document.querySelector<HTMLCanvasElement>("#game")!.getContext("2d")!
        );
        this.gameLoop(0);
    }

    private draw() {
        this.hexMap.draw(this.layout);
        if (this.highlightedHex) {
            let ring = this.hexMap.range(this.highlightedHex, 1);
            drawLines(this.hexMap.outlineHexGroup(this.layout, ring), "darkgreen", 2);
            for (let hex of ring) {
                drawPolygon(
                    this.hexMap.polygonCorners(this.layout, hex),
                    "rgba(0, 200, 0, 0.5)",
                    "rgba(0, 0, 200, 0)",
                    1
                );
            }
            drawPolygon(
                this.hexMap.polygonCorners(this.layout, this.highlightedHex),
                "rgba(0, 0, 200, 0.5)",
                "rgba(0, 0, 200, 0)",
                1
            );
        }
    }

    public gameLoop(timeStamp: DOMHighResTimeStamp) {
        let FPSDeltaTime = timeStamp - this.FPSOldTimeStamp;
        let UPSDeltaTime = timeStamp - this.UPSOldTimeStamp;
        let UIPSDeltaTime = timeStamp - this.UIPSOldTimeStamp;

        if (FPSDeltaTime > FPSInterval) {
            clearCanvas();
            this.draw();
            this.FPSOldTimeStamp = timeStamp - (FPSDeltaTime % FPSInterval);
            this.layout.changed = false;
        }

        if (UPSDeltaTime > UPSInterval) {
            this.UPSOldTimeStamp = timeStamp - (UPSDeltaTime % UPSInterval);
            this.update(UPSDeltaTime / 1000);
        }

        if (UIPSDeltaTime > UIPSInterval) {
            this.UIPSOldTimeStamp = timeStamp - (UIPSDeltaTime % UIPSInterval);
            updateStorageDispaly();
            //this.uiUpdate(UPSDeltaTime / 1000);
        }
        window.requestAnimationFrame((t) => this.gameLoop(t));
    }

    public update(deltaTime: number) {
        this.hexMap.update(deltaTime);
    }

    public async save() {
        let save = {
            layout: this.layout,
            hexMap: this.hexMap,
        };
        saveObject("save", save);
    }

    public async load() {
        let save = loadObject("save");
    }

    public zoom(factor: Vector2) {
        let hexAtCenter = this.hexMap.pixelToHex(this.layout, this.layout.center);
        this.layout.setSize(factor, true);
        if (hexAtCenter) {
            let newPosition = this.hexMap.hexToPixel(this.layout, hexAtCenter);
            this.layout.setOrigin(
                {
                    x: this.layout.center.x - newPosition.x,
                    y: this.layout.center.y - newPosition.y,
                },
                true
            );
        }
    }

    public async tapDown(position: Vector2 | Vector2Attributes | undefined) {
        this.tap = performance.now();
        if (!position) return;
        this.layout.changed = true;
        if (this.tapedHex) this.tapedHex.isHighlighted = false;
        this.tapedHex = this.hexMap.pixelToHex(this.layout, position) as Building;
        this.tapedHex.isHighlighted = true;
    }

    public async tapUp(position: Vector2 | Vector2Attributes | undefined) {
        this.tap = 0;
        if (!this.tapedHex) return;
        this.highlightedHex = this.tapedHex;
        let position2 = this.hexMap.hexToPixel(this.layout, this.tapedHex);
        this.layout.setOrigin(
            {
                x: this.layout.center.x - position2.x,
                y: this.layout.center.y - position2.y,
            },
            true
        );
        setStorageDisplayFromItemMap(this.tapedHex.publicStorage, this.tapedHex.publicStoragePS);
    }

    public async tapMove(position: Vector2 | Vector2Attributes | undefined) {
        if (!this.tap) return;
        if (!position) return;
        this.layout.setOrigin({ x: position.x, y: position.y }, true);

        if (performance.now() - this.tap < 100) return;
        this.tapedHex = undefined;
    }

    public debug(position: Vector2 | Vector2Attributes | undefined) {}
}

================
File: src/game/core/layout.ts
================
import { Vector2, Vector2Attributes } from "../models/vector";

const sqrt3 = Math.sqrt(3);

interface Orientation {
    f0: number;
    f1: number;
    f2: number;
    f3: number;
    b0: number;
    b1: number;
    b2: number;
    b3: number;
    startAngle: number;
}

interface LayoutAttributes {
    orientation: Orientation;
    size: Vector2;
    origin: Vector2;
    viewport: Vector2;
    center: Vector2;
}

export const orientation: Orientation = {
    f0: sqrt3,
    f1: sqrt3 / 2.0,
    f2: 0.0,
    f3: 3.0 / 2.0,
    b0: sqrt3 / 3.0,
    b1: -1.0 / 3.0,
    b2: 0.0,
    b3: 2.0 / 3.0,
    startAngle: 0.5,
};

export class Layout implements LayoutAttributes {
    public orientation: Orientation;
    public size: Vector2;
    public origin: Vector2;
    public viewport: Vector2;
    public changed: boolean = true;
    public center: Vector2;

    constructor(orientation: Orientation, size: Vector2Attributes, maxSize?: number, minSize?: number) {
        this.orientation = orientation;

        this.size = new Vector2(size.x, size.y, maxSize, minSize);

        let x = window.innerWidth;
        let y = window.innerHeight;

        this.origin = new Vector2(x / 2, y / 2);
        this.viewport = new Vector2(x, y);
        this.center = new Vector2(x / 2, y / 2);
    }

    public setOrientation(orientation: Orientation): void {
        this.changed = true;
        this.orientation = orientation;
    }

    public isVectorInViewport(vector: Vector2): boolean {
        return (
            vector.greaterThan({ x: -10, y: -10 }) &&
            vector.lessThan({ x: this.viewport.x + 10, y: this.viewport.y + 10 })
        );
    }

    public setOrigin(origin: Vector2 | Vector2Attributes, add: boolean = false): void {
        this.changed = true;
        if (add) {
            this.origin.add(origin);
        } else {
            this.origin = origin as Vector2;
        }
    }

    public reset(): void {
        this.changed = true;
        this.origin = this.center.clone();
        this.viewport = new Vector2(window.innerWidth, window.innerHeight);
    }

    public setSize(size: Vector2 | Vector2Attributes, add: boolean = false): void {
        this.changed = true;
        if (add) {
            this.size.add(size);
        } else {
            this.size = size as Vector2;
        }
    }

    public toJSON() {
        return {
            origin: this.origin,
            size: this.size,
        };
    }
}

export default Layout;

================
File: src/game/core/loadingScreen.ts
================
export default class LoadingScreen {
    private initSteps: number;
    private step: number = 0;

    private loadingScreen: HTMLDivElement;
    private loadingText: HTMLDivElement;
    private loadingProgress: HTMLProgressElement;

    constructor(initSteps: number) {
        this.initSteps = initSteps;
        this.loadingScreen = document.querySelector<HTMLDivElement>("#loadingScreen")!;
        this.loadingText = document.querySelector<HTMLDivElement>("#loadingText")!;
        this.loadingProgress = document.querySelector<HTMLProgressElement>("#loadingProgress")!;
    }

    public stepLoadingScreen(steps: number, nextStepText: string) {
        if (this.step === 0) {
            this.loadingProgress.max = this.initSteps;
        }
        this.step += steps;

        if (this.step >= this.initSteps) {
            this.loadingScreen.style.display = "none";
            return;
        }

        this.loadingProgress.value = this.step;
        this.loadingText.innerHTML = nextStepText;
    }
}

================
File: src/game/core/ui.ts
================
import { downArrow, upArrow } from "../../core/render/html";
import { floorToDigit, isPositive, roundToDigit } from "../../core/utils/numberUtils";
import { Item } from "../models/item";

let initialized: boolean = false;
let statsEl: HTMLDivElement;
let currentStorage: Map<string, Item>;
let currentStoragePS: Map<string, number>;

export function uiInitialize() {
    if (initialized) return;
    statsEl = <HTMLDivElement>document.getElementById("stats")!;
    initialized = true;
}

export function setStorageDisplayFromItemMap(storage: Map<string, Item>, storagePS: Map<string, number>) {
    if (!initialized) throw Error("UI not initialized");
    currentStorage = storage;
    currentStoragePS = storagePS;

    let storageStats: string = "";

    storage.forEach((item: Item) => {
        storageStats += `<div class="stat" id="${item.type}">
            <div class="stat-figure text-secondary">
                ${item.icon}
            </div>
            <div class="stat-title">${item.name}</div>
            <div class="stat-value">${roundToDigit(item.value, 2)}</div>
            <div class="stat-desc">${getChangedString(item.type)}</div>
        </div>`;
    });

    statsEl.innerHTML = storageStats;
}

export function updateStorageDispaly() {
    if (!currentStorage) return;

    currentStorage.forEach((item: Item) => {
        let statValue = statsEl.querySelector("#" + item.type + " .stat-value");
        let statChange = statsEl.querySelector("#" + item.type + " .stat-desc");
        if (!statValue || !statChange) return;
        statValue.innerHTML = floorToDigit(item.value, 2).toString();

        statChange.innerHTML = getChangedString(item.type);
    });
}

function getChangedString(type: string): string {
    if (!currentStoragePS) return "";

    let change = currentStoragePS.get(type);

    let changeString: string = "";
    if (change === undefined) {
        changeString = "...";
    } else {
        changeString = (isPositive(change) ? upArrow : downArrow) + " " + change.toString();
    }

    return changeString;
}

================
File: src/game/models/buildings/base.ts
================
import { Building } from "../building";
import { HexCoordinates } from "../hex";

export default class Base extends Building {
    constructor(postion: HexCoordinates, level: number = 1) {
        super(postion, "base", "base", level, 1, true);
    }
}

================
File: src/game/models/buildings/furnace.ts
================
import { Building } from "../building";
import { HexCoordinates } from "../hex";
import { Recipe } from "../recipe";
import WoodToCoal from "../recipes/woodToCoal";

export default class Furnace extends Building {
    constructor(postion: HexCoordinates, level: number = 1, recipe?: Recipe) {
        super(postion, "furnace", "furnace", level, 1, true, recipe ?? new WoodToCoal());
    }
}

================
File: src/game/models/items/coal.ts
================
import { Item } from "../item";

export default class Coal extends Item {
    constructor() {
        super(
            "coal",
            "Coal",
            1,
            "A piece of coal",
            '<img src="data:image/png;base64,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">'
        );
    }
}

================
File: src/game/models/items/copper.ts
================
import { Item } from "../item";

export default class Copper extends Item {
    constructor() {
        super(
            "copper",
            "Copper",
            1,
            "A piece of copper",
            '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAACXBIWXMAAAsTAAALEwEAmpwYAAAE4ElEQVR4nO2by4/bVBTGz0Q0fk0RQggWrBBI7IANjxWPBfTPqAoIMbHdaloEiAWeNMkkVSalM7wkXjvKgkcrAdtWakV5F9iAxENAWbUqsUNiXztBGDk06Uyw09LxvecyOT/pbGZz5p7j+13nfj4ABEEQBEEQBEEQBEEQBEEQBEEQBEEIousY17OadjJqGf3B2vY4z4hWjDCoqEdiB4rU0BRiB/TwgP573oUfRX91e+w7xdjdA29SA1IIysU1XsVny1rsLRZi14JhtEtwLzVhAlbXf8v9qW8Zcffpq8aFXxdr1IAJopYxyFdulNjd/a/Cj+IUNWD9019Rbhqs8pGbtGhbwOLHYBs14QJBufgkR7lJb8IC3DbKP/OwmvohR7lJDxN2zXzhR7CG/isvuZkSL4z/gVknahkRT7nJOAc+wV63FPhV7UbuckMH8ZQGLCm2ALnJasLtMOsENfUob7mZEo/ArBM0tJ94y82UeAlmnahphCLkJlWCTPgUZp3+qjC5STsDzsKsE63ovf6hf66KPVtM4dftgGMw6/TKyg5vsXC6bcGfAgs/cE044dlwM2wl/nDmr2NV7QQ3R6umHp3maHkOXBtU1WPRSs75V4f5I1ZTP4gdUEFeR0s7n3fhBxveiorJW9HhjPzFsKGd5ZU/aYK/pMSePfdeDDAHssEqyiFhjpYN903m98vKMq/8YUOPO3sv5vdM2AGywRr6mdyf+lbGW5EJz0/mD+vaj3nnjzLyty14FWSjfzA/3e1f6keYCR9P5k/OiDzlJtivxN7uuazX169gqzpa4cR2vxxHKzn8heY3YXBmETSQhaBcfGLT2/3gfNx7ZtsVXaT5ZeVx0fk9C+4CWUhezzaz+CDZ7nb6ds8MGx4e5Q8q6tu85GbKA1ACWWB17Rde293NChNeHOdf1r4Xnb9twuvwf3W0/ut2dy9xkRY1jUB0fteEr0EGujXjBu5yY2UfxLEDV1/2AXyFciP1QexXFJO73FgZUYI7gmfVnVj5z9twD3b9kwPwCPftbmXKwKO9qnIYK3/bBBO7/lN/geYlN252vMzq2re85SazARa8gV3/5BcoEyI3VmoBPkv8BKz8rgXfYNcfEjNlw93NUwIdLRPORc/N/3VRbsQ6aq4JHez6Qzh2tBK5EbRwa7wDjkdN3RtfFXOUG2m/smZl5cHO3sKXwh0tC056JbiFOcr9nX2Fzy/8TVTjk7We6uyBW7eUo9VFnhEbOmo19TgXR61lhEFVfT/TUZPA0dIxZ8SSxrAD2jle+Ucy2bbhnVRHDdvRCpBnxPz9Sl2Yo2bDQ9I5Wgx5RizrC73NRNZbWduEV+RztFq4M2KJRgtz1Ew4LZWjxZBnxIYXimLX3/9557rDGNvRCpBnxHxHKYlev7cAd0rjaDHkGbGgqr4r3FErwYI8jlYDd0YsrGs/iF5/24TX5HG0WrgzYmHKhSL39Y8+bcF2tHzkGTHXgWtQHTVsR8tHnhHrLSm7sNbfKcHd6I5WgDwj5leUt7DWP/y0BdvRCpBnxFhd+4633Ez9tAXd0WrizoiFTd3HWv/w0xZsR6uPPCO2wVETnN+1wMN3tFZwZ8TCpt5Bc9RM+Ajd0eohz4h1y8oD3r7CF1vCUSMIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIAmTgbw5Q8RmmtebGAAAAAElFTkSuQmCC">'
        );
    }
}

================
File: src/game/models/items/copperOre.ts
================
import { Item } from "../item";

export default class CopperOre extends Item {
    constructor() {
        super(
            "copperOre",
            "Copper Ore",
            1,
            "A piece of copper ore",
            '<img src="data:image/png;base64,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">'
        );
    }
}

================
File: src/game/models/items/iron.ts
================
import { Item } from "../item";

export default class Iron extends Item {
    constructor() {
        super(
            "iron",
            "Iron",
            1,
            "A piece of iron",
            '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAACXBIWXMAAAsTAAALEwEAmpwYAAAFIElEQVR4nO2by4/bRBzHhwMV9IAQQnDghITEDbjwOPE4QP+MavMSm4rGs6F5zTjjxPY6G9uJN9luJaDcKAdelYBrK7XiDaVcQOIh8Ti1AqmVgN0+hJG7ZBtST9psPB5r/ftIv8tevpsZ+zvj+c4PIQAAAAAAAAAAAAAAAAAAAAAAAAAAYqLM7Puo2Tut28PLHe+IH2Xp3eEmMez3GGN7YEJDYIzt1VZW/4h64Edl9df9SmvFL5Sbb8AEhNAw7IGowVetvr94iPk5TK9VpkSehkmYoGl5v0VuO87QLzWM7YEfVRbTAUzABLozvBKp3WhdP7+k3jD4W0U+hgkYg+j6g8GgibCb0FLIRqFQuB0m4T/qrW5lfrtZC7UbXmUP1h8Z6aceYvY+FGc3nAnAZCH1Az9C7fR/EWY33Amga9v/QNoxnOElkXbDeQM+lf27EwE23AdE2w0sxFOoas5Lou2GVwuYPorSTt10j4u2G36RLEo7quX9JNxuuDZE11HaadvDzTjshjMBn6G0Y419AYu1m5CdkELOobTT6g7+HB0VC7Wb0DeAnEBpp6J29hUPsTM5TK/G+ORfyWJyKovZQ2g3scSce4nhnhKVaNVN9/i0RIsxdg8xeid0J1r94A3V7cElYrofMMbuQMlNtLzfox74zviuKLCpsnqMo79HW1k9J1S/3fXz5ea7CKHbUNKoGa4n6serE7uiPFafmdSv6t1lUfqs4/nFinbdxkrqPpQ0mpb3a+S243B2RQoZ3qjf/1GIPjFD1hHyKkoaRoS+a93kIyyr0E8m9YM1Ikr9mm4Hdheuj+nXaLcmWqzj+YuV1kyJVrD4R6n/P7vh7KIwxneipFDTnZfn/eGGs+Zjuryjg7Ray35xXn3TnU0/ixtPoKQQbM92/Lp7W697Yak5014+U6KZbX3DfUuU3fAqj9UiSgqs0/9ZmN1grg0cHuk3rf73ouyGX+QoSgr6jInWrHaTu8lBWrs7/Fuk3XDWobMoCdRN737RdpObshAzxu661QV4p3aT6IW4rjsHRNtNjlelxmM1zd5/63YTsT5uPCV7/FFw41i43WDeU0hzdcM9Jtxu+G/hAdnjz/0CjdRuMGcCMDnSXPa+FW03/Amgr8sef6Tbw41Y7AaHTsDnQZ4Qj92E1jeyxx9ZvfWJ28hhZyfC6rzZO/zPuN0poWc3oopcTHeihelJzV69EOhXW8FRcdz6CbhlXTc7zy9WWl/Fnmgp9HSQaFV1+9liRfsi+FuMg381GPxMiT68qxKtsuQesSBRo6Z7UkyitrZJzN773EQtAYnWXpk9YtcStY53XqR+YJOFJfp2aKImO9FqSO4Rq7VtS5R+c+LMKaOQFxKYaHlSe8R4N/Tmqa1dWYi+Ql9JXqLlyO0RCzw6Sv2pH4EKOZOoRItI7hELDhRjTdQwvbx/fDGWnWjVJfeI1Qy7OK/+rGdO+YPq48lJtEy5PWINw3lnHv2dnDlll8hiYhItVXKPmGr1f4g7Ucsq9LXEJFqG5B6xtj3YEGk3U6+2yE60sOQesVK/f7fURE12olWV3CNW0zoLou2GV4WS+qT8RMuU2yPWMJw3RdvN1KstshMtVXKPmGr1vxNtN1MegKPSE6225B6xdnfwVxx2E65PzkpPtCzJPWLLY4ka/za0KH16QXqi1ZLcI9Za8S5eb76IVz+r0I+kJ1oVyT1iddN9rljRvtwViRoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgJ/AuaOSGNBnZD4gAAAABJRU5ErkJggg==">'
        );
    }
}

================
File: src/game/models/items/ironOre.ts
================
import { Item } from "../item";

export default class IronOre extends Item {
    constructor() {
        super(
            "ironOre",
            "Iron Ore",
            1,
            "A piece of iron ore",
            '<img src="data:image/png;base64,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">'
        );
    }
}

================
File: src/game/models/items/stone.ts
================
import { Item } from "../item";

export default class Stone extends Item {
    constructor() {
        super(
            "stone",
            "Stone",
            1,
            "A stone",
            '<img src="data:image/png;base64,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">'
        );
    }
}

================
File: src/game/models/items/wood.ts
================
import { Item } from "../item";

export default class Wood extends Item {
    constructor() {
        super(
            "wood",
            "Wood",
            1,
            "A piece of wood",
            '<img src="data:image/png;base64,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">'
        );
    }
}

================
File: src/game/models/recipes/ironOreToIron.ts
================
import Coal from "../items/coal";
import Iron from "../items/iron";
import IronOre from "../items/ironOre";
import { Recipe } from "../recipe";

export default class IronOreToIron extends Recipe {
    constructor() {
        super("IronOreToIron", "Iron Ore to Iron", "iron", [new IronOre(), new Coal()], [new Iron()]);
    }
}

================
File: src/game/models/recipes/wood.ts
================
import Wood from "../items/wood";
import { Recipe } from "../recipe";

export default class WoodRecipe extends Recipe {
    constructor() {
        super("wood", "Wood", "wood", [], [new Wood()]);
    }
}

================
File: src/game/models/recipes/woodToCoal.ts
================
import Coal from "../items/coal";
import Wood from "../items/wood";
import { Recipe } from "../recipe";

export default class WoodToCoal extends Recipe {
    constructor() {
        super("WoodToCoal", "Wood to Coal", "coal", [new Wood()], [new Coal()]);
    }
}

================
File: src/game/models/building.ts
================
import { floorToDigit } from "../../core/utils/numberUtils";
import { buildingTypeToImage } from "../const";
import Hex from "./hex";
import { Item } from "./item";
import { Recipe } from "./recipe";

export interface BuildingAttributes {
    type: string;
    level: number;
    image: string[];
    range: number;
    conenctToSameType: boolean;
    updateable: boolean;
    outputs?: Item;
    outputPerSec?: number;
    input?: Item;
    inputPerSec?: number;
    placableOn?: string[];
}

export class Building extends Hex implements BuildingAttributes {
    type: string;
    level: number;
    image: [string];
    range: number;
    conenctToSameType: boolean;
    updateable: boolean = false;
    recipe?: Recipe;
    placableOn?: [string];

    publicStorage: Map<string, Item> = new Map();
    publicStorageChange: Map<string, [number, number]> = new Map();
    publicStoragePS: Map<string, number> = new Map();

    privateStorage: Map<string, Item> = new Map();

    isHighlighted: boolean = false;

    constructor(
        position: { q: number; r: number; s: number },
        type: string,
        image?: string | [string],
        level?: number,
        range?: number,
        conenctToSameType?: boolean,
        recipe?: Recipe,
        placableOn?: [string]
    ) {
        super(position.q, position.r, position.s);
        this.type = type;
        if (typeof image === "string") {
            this.image = [image];
        } else {
            // @ts-ignore
            this.image = image ?? buildingTypeToImage[type];
        }
        this.level = level ?? 1;
        this.range = range ?? 0;
        this.conenctToSameType = conenctToSameType ?? true;
        this.recipe = recipe;
        this.placableOn = placableOn;
        if (recipe) {
            this.setRecipe(recipe);
        }
    }

    public setRecipe(recipe: Recipe) {
        this.recipe = recipe;
        this.updateable = true;
        this.recipe.outputs.forEach((item: Item) => {
            let sItem = item.clone();
            sItem.value = 0;
            this.publicStorage.set(sItem.type, sItem);
        });
        this.recipe.inputs.forEach((item: Item) => {
            let sItem = item.clone();
            sItem.value = 0;
            this.privateStorage.set(sItem.type, sItem);
        });
    }

    public update(deltaTime: number, nearbyBuildings: Building[]) {
        this.getRecipeInputFromNearbyBuildings(nearbyBuildings);
        this.setStorageBasedOnRecipe(deltaTime);
    }

    setStorageBasedOnRecipe(deltaTime: number) {
        let allInputsAvailable = true;
        const inputs = this.recipe!.inputs;
        const outputs = this.recipe!.outputs;
        for (let i = 0; i < inputs.length; i++) {
            if (this.privateStorage.get(inputs[i].type)?.value! >= inputs[i].value) {
                allInputsAvailable = true;
            } else {
                allInputsAvailable = false;
                break;
            }
        }

        if (!allInputsAvailable) {
            this.addDeltaToChange(0, deltaTime, null);
            return;
        }

        for (let i = 0; i < outputs.length; i++) {
            let item = outputs[i];
            let storage = this.publicStorage.get(item.type);

            if (!storage) return; // * INFO this should never happen

            let change = deltaTime * item.value;
            storage.value += change;

            this.addDeltaToChange(change, deltaTime, item.type);
        }

        for (let i = 0; i < inputs.length; i++) {
            let item = inputs[i];
            let storage = this.privateStorage.get(item.type);

            if (!storage) return; // * INFO this should never happen

            storage.value -= deltaTime * item.value;
        }
    }

    addDeltaToChange(change: number, deltaTime: number, type: string | null) {
        if (!this.isHighlighted) return;
        if (type) {
            let current = this.publicStorageChange.get(type);
            if (!current) {
                this.publicStorageChange.set(type, [change, deltaTime]);
            } else {
                current[0] += change;
                current[1] += deltaTime;
                if (current[1] >= 1) {
                    this.publicStoragePS.set(type, floorToDigit(current[0], 2));
                    current[0] = 0;
                    current[1] = 0;
                }
            }
        } else {
            for (let i = 0; i < this.recipe!.outputs.length; i++) {
                let item = this.recipe!.inputs[i];
                let current = this.publicStorageChange.get(item.type);
                if (!current) {
                    this.publicStorageChange.set(item.type, [change, deltaTime]);
                } else {
                    current[0] += change;
                    current[1] += deltaTime;
                    if (current[1] >= 1) {
                        this.publicStoragePS.set(item.type, floorToDigit(current[0], 2));
                        current[0] = 0;
                        current[1] = 0;
                    }
                }
            }
        }
    }

    getRecipeInputFromNearbyBuildings(nearbyBuildings: Building[]) {
        for (let i = 0; i < this.recipe!.inputs.length; i++) {
            let item = this.recipe!.inputs[i];
            let privareStorageValue = this.privateStorage.get(item.type)!.value;
            if (privareStorageValue >= this.recipe!.inputs[i].value) continue;

            for (let j = 0; j < nearbyBuildings.length; j++) {
                if (!(nearbyBuildings[j] instanceof Building)) continue;

                let storage = nearbyBuildings[j].publicStorage.get(item.type);
                if (!storage) continue;

                let min = Math.min(item.value, storage.value);
                privareStorageValue += min;
                storage.value -= min;

                this.addDeltaToChange(-min, 0, item.type);

                if (privareStorageValue >= item.value) {
                    break;
                }
            }
        }
    }

    public toJSON() {
        return {
            q: this.q,
            r: this.r,
            s: this.s,
            type: this.type,
            level: this.level,
        };
    }
}

================
File: src/game/models/hex.ts
================
export interface HexCoordinates {
    q: number;
    r: number;
    s: number;
}

export interface HexAttributes {
    id: string;
    exists: boolean;
}

export class Hex implements HexCoordinates, HexAttributes {
    q: number;
    r: number;
    s: number;

    id: string;
    exists: boolean;

    constructor(q: number, r: number, s: number, exists: boolean = true) {
        if (Math.round(q + r + s) !== 0) throw "q + r + s must be 0";
        this.q = q;
        this.r = r;
        this.s = s;
        this.id = q + "_" + r + "_" + s;
        this.exists = exists;
    }

    public getPosition(): HexCoordinates {
        return { q: this.q, r: this.r, s: this.s };
    }
}

export default Hex;

================
File: src/game/models/hexagonMap.ts
================
import alea from "alea";
import { createNoise2D } from "simplex-noise";
import Layout from "../core/layout";
import { drawImage, drawPolygon } from "./../../core/render/canvas";
import { Building } from "./building";
import Hex, { HexCoordinates } from "./hex";
import WoodRecipe from "./recipes/wood";
import { Vector2, Vector2Attributes } from "./vector";

let imgs = [
    "./../../../src/assets/img/grass_12.png",
    "./../../../src/assets/img/grass_13.png",
    "./../../../src/assets/img/grass_14.png",
    "./../../../src/assets/img/grass_15.png",
    "./../../../src/assets/img/grass_16.png",
    "./../../../src/assets/img/dirt_13.png",
    "./../../../src/assets/img/dirt_14.png",
    "./../../../src/assets/img/dirt_15.png",
    "./../../../src/assets/img/dirt_16.png",
    "./../../../src/assets/img/dirt_17.png",
];

export class HexagonMap {
    private hexagons: Map<string, Building> = new Map();
    private seed: string;
    private directions: HexCoordinates[] = [
        { q: 1, r: 0, s: -1 },
        { q: 1, r: -1, s: 0 },
        { q: 0, r: -1, s: 1 },
        { q: -1, r: 0, s: 1 },
        { q: -1, r: 1, s: 0 },
        { q: 0, r: 1, s: -1 },
    ];

    private PI2: number = Math.PI * 2;
    private anglesCosSin = [
        new Vector2(Math.cos((this.PI2 * 0.5) / 6), Math.sin((this.PI2 * 0.5) / 6)),
        new Vector2(Math.cos((this.PI2 * -0.5) / 6), Math.sin((this.PI2 * -0.5) / 6)),
        new Vector2(Math.cos((this.PI2 * -1.5) / 6), Math.sin((this.PI2 * -1.5) / 6)),
        new Vector2(Math.cos((this.PI2 * -2.5) / 6), Math.sin((this.PI2 * -2.5) / 6)),
        new Vector2(Math.cos((this.PI2 * -3.5) / 6), Math.sin((this.PI2 * -3.5) / 6)),
        new Vector2(Math.cos((this.PI2 * -4.5) / 6), Math.sin((this.PI2 * -4.5) / 6)),
    ];

    private hexPositionCache: Map<string, [Vector2[], Vector2]> = new Map();

    constructor(radius: number, seed: string = "HexFactory") {
        this.seed = seed;
        let prng = alea(this.seed);
        let noise2D = createNoise2D(prng);
        for (let q = -radius; q <= radius; q++) {
            const r1 = Math.max(-radius, -q - radius);
            const r2 = Math.min(radius, -q + radius);
            for (let r = r1; r <= r2; r++) {
                let imgn = imgs[Math.floor(Math.abs(noise2D(-q, r)) * 10)];
                this.hexagons.set(
                    q + "_" + r + "_" + (-q - r),
                    new Building({ q: q, r: r, s: -q - r }, imgn, undefined, 1, 1, true, new WoodRecipe())
                );
            }
        }
    }

    private getCachedHexPosition(hex: Hex, layout: Layout): [Vector2[], Vector2] {
        let cached = this.hexPositionCache.get(hex.id);
        if (cached !== undefined) {
            return cached;
        }

        let polygonCorners = this.polygonCorners(layout, hex);
        let hexPixel = this.hexToPixel(layout, hex);
        this.hexPositionCache.set(hex.id, [polygonCorners, hexPixel]);
        return [polygonCorners, hexPixel];
    }

    public update(deltaTime: number) {
        this.hexagons.forEach((hex) => {
            if (!hex.updateable) return;
            hex.update(deltaTime, this.range(hex, hex.range) as Building[]);
        });
    }

    public draw(layout: Layout) {
        if (layout.changed) {
            this.hexPositionCache.clear();
        }

        let drawnHexagons: number = 0;

        this.hexagons.forEach((hex) => {
            let [polygonCorners, hexPixel] = this.getCachedHexPosition(hex, layout);
            if (!this.isHexInViewport(layout, hex, polygonCorners)) return;
            drawnHexagons++;
            drawImage(hexPixel, layout.size.x, layout.size.y, hex.type);
            drawPolygon(polygonCorners, null, "darkgray", 1);
        });

        console.log("drawn hexagons: " + drawnHexagons);
    }

    public getHexagon(id: string): Hex | undefined {
        return this.hexagons.get(id);
    }

    public getHexagonByCords(cords: HexCoordinates): Hex | undefined {
        return this.hexagons.get(cords.q + "_" + cords.r + "_" + cords.s);
    }

    public replaceBuilding(hex: Building) {
        this.hexagons.set(hex.id, hex);
    }

    public axialToCube(axial: Vector2): HexCoordinates {
        const q = axial.x;
        const r = axial.y;
        const s = -q - r;
        return { q, r, s };
    }

    public cubeToAxial(cube: HexCoordinates): Vector2 {
        const x = cube.q;
        const y = cube.r;
        return new Vector2(x, y);
    }

    public add(a: Hex | HexCoordinates, b: Hex | HexCoordinates, create: boolean = false): Hex | undefined {
        let hex: Hex | undefined = this.getHexagonByCords({ q: a.q + b.q, r: a.r + b.r, s: a.s + b.s });
        if (!hex && create) {
            hex = new Hex(a.q + b.q, a.r + b.r, a.s + b.s, false);
        }
        return hex;
    }

    public subtract(a: Hex | HexCoordinates, b: Hex | HexCoordinates, create: boolean = false): Hex | undefined {
        let hex: Hex | undefined = this.getHexagonByCords({ q: a.q - b.q, r: a.r - b.r, s: a.s - b.s });
        if (!hex && create) {
            hex = new Hex(a.q - b.q, a.r - b.r, a.s - b.s, false);
        }
        return hex;
    }

    public multiply(a: Hex | HexCoordinates, k: number, create: boolean = false): Hex | undefined {
        let hex: Hex | undefined = this.getHexagonByCords({ q: a.q * k, r: a.r * k, s: a.s * k });
        if (!hex && create) {
            hex = new Hex(a.q * k, a.r * k, a.s * k, false);
        }
        return hex;
    }

    public equals(a: Hex | HexCoordinates, b: Hex | HexCoordinates): boolean {
        return a.q === b.q && a.r === b.r && a.s === b.s;
    }

    public length(a: Hex | HexCoordinates): number {
        return (Math.abs(a.q) + Math.abs(a.r) + Math.abs(a.s)) / 2;
    }

    public distance(a: Hex | HexCoordinates, b: Hex | HexCoordinates): number {
        let sub = this.subtract(a, b);
        if (sub) {
            return this.length(sub);
        }
        return 1;
    }

    public getNeighbor(hex: Hex, direction: HexCoordinates | number, create: boolean = false): Hex | undefined {
        if (typeof direction === "number") {
            direction = this.directions[direction];
        }
        return this.add(hex, direction, create);
    }

    public getNeighbors(hex: Hex): (Hex | undefined)[] {
        let results: (Hex | undefined)[] = [];
        for (let i = 0, n = this.directions.length; i < n; i++) {
            let neighbor = this.getNeighbor(hex, i);
            results.push(neighbor);
        }
        return results;
    }

    public isNeighbor(a: Hex | HexCoordinates, b: Hex | HexCoordinates): boolean {
        return this.distance(a, b) === 1;
    }

    public ring(hex: Hex, radius: number): Hex[] {
        let results: Hex[] = [];
        let current = this.add(hex, this.multiply(this.directions[4], radius, true)!, true)!;
        for (let i = 0; i < 6; i++) {
            for (let j = 0; j < radius; j++) {
                if (current.exists) {
                    results.push(current);
                    current = this.getNeighbor(current, i, true)!;
                } else {
                    current = this.getNeighbor(current, i, true)!;
                }
            }
        }
        return results;
    }

    public range(hex: Hex, radius: number): Hex[] {
        let results: Hex[] = [];
        for (let i = 0; i <= radius; i++) {
            results = results.concat(this.ring(hex, i));
        }
        return results;
    }

    public hexToPixel(layout: Layout, hex: Hex | HexCoordinates): Vector2 {
        const M = layout.orientation;
        const size = layout.size;
        const origin = layout.origin;
        const x = (M.f0 * hex.q + M.f1 * hex.r) * size.x;
        const y = (M.f2 * hex.q + M.f3 * hex.r) * size.y;
        return new Vector2(x + origin.x, y + origin.y);
    }

    public pixelToHex(layout: Layout, p: Vector2 | Vector2Attributes): Hex | undefined {
        const M = layout.orientation;
        const size = layout.size;
        const origin = layout.origin;
        const pt = new Vector2((p.x - origin.x) / size.x, (p.y - origin.y) / size.y);
        const q = M.b0 * pt.x + M.b1 * pt.y;
        const r = M.b2 * pt.x + M.b3 * pt.y;
        return this.roundHex({ q: q, r: r, s: -q - r });
    }

    public roundHex(hex: Hex | HexCoordinates): Hex | undefined {
        let q = Math.round(hex.q);
        let r = Math.round(hex.r);
        let s = Math.round(hex.s);
        const qDiff = Math.abs(q - hex.q);
        const rDiff = Math.abs(r - hex.r);
        const sDiff = Math.abs(s - hex.s);
        if (qDiff > rDiff && qDiff > sDiff) {
            q = -r - s;
        } else if (rDiff > sDiff) {
            r = -q - s;
        } else {
            s = -q - r;
        }
        return this.getHexagonByCords({ q: q, r: r, s: s });
    }

    public hexCornerOffset(layout: Layout, corner: number): Vector2 {
        const size = layout.size;
        return new Vector2(size.x * this.anglesCosSin[corner].x, size.y * this.anglesCosSin[corner].y);
    }

    public polygonCorners(layout: Layout, hex: Hex | HexCoordinates): Vector2[] {
        const corners: Vector2[] = [];
        const center = this.hexToPixel(layout, hex);
        for (let i = 0; i < 6; i++) {
            const offset = this.hexCornerOffset(layout, i);
            corners.push(offset.add(center));
        }
        return corners;
    }

    public isHexInViewport(layout: Layout, hex: Hex | HexCoordinates, corners: Vector2[] | null = null): boolean {
        corners = corners ?? this.polygonCorners(layout, hex);
        for (let i = 0, n = corners.length; i < n; i++) {
            if (layout.isVectorInViewport(corners[i])) {
                return true;
            }
        }

        return false;
    }

    public outlineHexGroup(layout: Layout, hexagons: Hex[]): [Vector2, Vector2][] {
        let lines: [Vector2, Vector2][] = [];
        for (let i = 0, n = hexagons.length; i < n; i++) {
            let hex = hexagons[i];
            let neighbors = this.getNeighbors(hex);

            for (let j = 0, n = neighbors.length; j < n; j++) {
                let neighbor = neighbors[j];

                if (!neighbor || hexagons.indexOf(neighbor) === -1) {
                    let hexCenter = this.hexToPixel(layout, hex);
                    let offset = this.hexCornerOffset(layout, j);
                    let offset1 = this.hexCornerOffset(layout, (j + 1) % 6);
                    let p1 = new Vector2(hexCenter.x + offset.x, hexCenter.y + offset.y);
                    let p2 = new Vector2(hexCenter.x + offset1.x, hexCenter.y + offset1.y);
                    lines.push([p1, p2]);
                }
            }
        }
        return lines;
    }

    public toJSON() {
        return {
            hexagons: this.hexagons,
            seed: this.seed,
        };
    }
}

export default HexagonMap;

================
File: src/game/models/item.ts
================
export interface ItemAttributes {
    type: string;
    name: string;
    value: number;
    description?: string;
    icon?: string;
}

export class Item implements ItemAttributes {
    type: string;
    name: string;
    value: number;
    description?: string;
    icon?: string;

    constructor(type: string, name: string, value: number, description?: string, icon?: string) {
        this.type = type;
        this.name = name;
        this.description = description;
        this.icon = icon;
        this.value = value;
    }

    public clone(): Item {
        return new Item(this.type, this.name, this.value, this.description, this.icon);
    }
}

================
File: src/game/models/recipe.ts
================
import { Item } from "./item";

export interface RecipeAttributes {
    id: string;
    name: string;
    icon?: string;
    inputs: Item[];
    outputs: Item[];
}

export class Recipe implements RecipeAttributes {
    id: string;
    name: string;
    icon?: string;
    inputs: Item[];
    outputs: Item[];

    constructor(
        id: string,
        name: string,
        icon?: string,
        inputs?: Item[],
        outputs?: Item[]
    ) {
        this.id = id;
        this.name = name;
        this.icon = icon;
        this.inputs = inputs ?? [];
        this.outputs = outputs ?? [];
    }
}

================
File: src/game/models/vector.ts
================
export interface Vector2Attributes {
    x: number;
    y: number;
    maxY?: number;
    minY?: number;
    maxX?: number;
    minX?: number;
}

export class Vector2 implements Vector2Attributes {
    public x: number;
    public y: number;
    public maxY?: number;
    public minY?: number;
    public maxX?: number;
    public minX?: number;

    constructor(x: number, y: number, max?: number, min?: number) {
        this.x = x;
        this.y = y;
        this.maxX = max;
        this.maxY = max;
        this.minX = min;
        this.minY = min;
    }

    public add(v: Vector2 | Vector2Attributes): Vector2 {
        this.x = this.maxX ? Math.min(this.x + v.x, this.maxX) : this.x + v.x;
        this.y = this.maxY ? Math.min(this.y + v.y, this.maxY) : this.y + v.y;
        this.x = this.minX ? Math.max(this.x, this.minX) : this.x;
        this.y = this.minY ? Math.max(this.y, this.minY) : this.y;
        return this;
    }

    public subtract(v: Vector2 | Vector2Attributes): Vector2 {
        this.x = this.minX ? Math.max(this.x - v.x, this.minX) : this.x - v.x;
        this.y = this.minY ? Math.max(this.y - v.y, this.minY) : this.y - v.y;
        this.x = this.maxX ? Math.min(this.x, this.maxX) : this.x;
        this.y = this.maxY ? Math.min(this.y, this.maxY) : this.y;
        return this;
    }

    public multiply(k: number): Vector2 {
        this.x *= k;
        this.y *= k;
        return this;
    }

    public equal(v: Vector2 | Vector2Attributes): boolean {
        return Math.round(this.x) === Math.round(v.x) && Math.round(this.y) === Math.round(v.y);
    }

    public greaterThan(v: Vector2 | Vector2Attributes): boolean {
        return this.x > v.x && this.y > v.y;
    }

    public lessThan(v: Vector2 | Vector2Attributes): boolean {
        return this.x < v.x && this.y < v.y;
    }

    public difference(v: Vector2 | Vector2Attributes): Vector2 {
        return new Vector2(Math.abs(this.x - v.x), Math.abs(this.y - v.y));
    }

    public toString(): string {
        return `(${this.x}, ${this.y})`;
    }

    public clone(): Vector2 {
        return new Vector2(this.x, this.y, this.maxX, this.minX);
    }

    public toJSON() {
        let returnStrg = {
            x: this.x,
            y: this.y,
        };
        if (this.maxX) {
            //@ts-ignore
            returnStrg.max = this.maxX;
        }
        if (this.minX) {
            //@ts-ignore
            returnStrg.min = this.minX;
        }
        return returnStrg;
    }
}

export class Vector3 {
    public x: number;
    public y: number;
    public z: number;
    constructor(x: number, y: number, z: number) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}

================
File: src/game/const.ts
================
export default {};

export const defaultSettings = {
    layout: {
        maxSize: 70,
        minSize: 15,
    },
};

export const defaultTiles = [
    "grass",
    "water",
    "sand",
    "stone",
    "dirt",
    "snow",
    "ice",
    "lava",
    "obsidian",
    "mud",
    "clay",
    "sandstone",
    "marble",
    "granite",
    "basalt",
];

interface BuildingType {
    [index: string]: string[];
}


export const buildingTypeToImage: BuildingType = {
    forest: ["./../assets/img/forest.png"],
    rock: ["rock.png"],
    furnace: ["rock.png"],
};

export function loadImages(images: string[]) {
    let imgs: HTMLImageElement[] = [];
    for (let i = 0; i < images.length; i++) {
        let img = new Image();
        img.src = images[i];
        imgs.push(img);
    }
    return imgs;
}

================
File: src/main.css
================
@font-face {
    font-display: swap;
    font-family: "Comfortaa";
    font-style: normal;
    font-weight: 300;
    src: url("./assets/fonts/Comfortaa-Light.ttf") format("truetype");
}

@font-face {
    font-display: swap;
    font-family: "Comfortaa";
    font-style: normal;
    font-weight: 400;
    src: url("./assets/fonts/Comfortaa-Regular.ttf") format("truetype");
}

@font-face {
    font-display: swap;
    font-family: "Comfortaa";
    font-style: normal;
    font-weight: 700;
    src: url("./assets/fonts/Comfortaa-Bold.ttf") format("truetype");
}

@font-face {
    font-display: swap;
    font-family: "Comfortaa";
    font-style: normal;
    font-weight: 600;
    src: url("./assets/fonts/Comfortaa-SemiBold.ttf") format("truetype");
}

@tailwind base;
@tailwind components;
@tailwind utilities;

.top-nav {
    position: fixed;
    top: 0px;
    left: 0px;
    right: 0px;
    display: flex;
    margin: 0.5rem;
}

.stat {
    padding-left: 1rem;
    padding-right: 1rem;
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
}

.stat-value {
    font-size: 1.25rem;
    line-height: 1.5rem;
    font-weight: 700;
}

.stat-figure {
    height: 48px;
    width: 48px;
}

.btm-nav-cards {
    display: flex;
    position: fixed;
    bottom: 3rem;
    width: 100%;
    opacity: 100%;
    align-items: center;
    justify-content: space-around;
    overflow: hidden;
    transition: opacity 0.25s ease-in-out;
}

.btm-nav-cards:focus {
    opacity: 0;
}

canvas {
    touch-action: none !important;
}
/*
canvas {
    background-color: darkslateblue;
}

body {
    overflow: hidden;
    touch-action: none;
    width: max-content;
}

.hidden {
    display: none !important;
}

.footer {
    position: absolute;
    margin: auto;
    bottom: 1svh;
    left: 0;
    right: 0;
    width: 80svw;
    max-width: 800px;
    height: 3svh;
    background-color: #323232;
    color: #fff;
    border-radius: 12px;
}

.footer .buttons {
    margin-top: -2svh;
    display: flex;
    align-items: flex-start;
    justify-content: space-around;
    flex-direction: row;
}

#loadingScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000;
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    font-size: 2em;
}

#loadingProgress {
    width: 90%;
    height: 20px;
    background-color: #fff;
    border-radius: 10px;
    margin: 10px;
    overflow: hidden;
} */

================
File: src/main.ts
================
import "./main.css";
import Game from "./game/core/game";

addEventListener("load", () => new Game());

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .editorconfig
================
[*]
charset = utf-8
indent_style = space
indent_size = 4
end_of_line = lf
trim_trailing_whitespace = true
insert_final_newline = true
max_line_length = 120

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HEXFAC</title>
    </head>
    <body class="bg-neutral" data-theme="dark">
        <div class="ui">
            <div class="top-nav">
                <div class="stats shadow" id="stats"></div>
            </div>
            <div class="btm-nav btm-nav-xs">
                <button>
                    <span class="btm-nav-label">Upgrades</span>
                </button>
                <button class="active">
                    <span class="btm-nav-label">Buildings</span>
                </button>
                <button>
                    <span class="btm-nav-label">Statics</span>
                </button>
            </div>
            <div class="btm-nav-cards">
                <div class="card w-11/12 bg-base-100 shadow-xl">
                    <div class="card-body"></div>
                </div>
            </div>
        </div>
        <canvas id="game"></canvas>
        <div id="loadingScreen">
            <div id="loadingText">Loading...</div>
            <progress id="loadingProgress" value="0" max="100"></progress>
        </div>
        <div id="app"><div id="debug"></div></div>
        <script type="module" src="/src/main.ts"></script>
    </body>
</html>

================
File: package.json
================
{
    "name": "hexfac",
    "private": true,
    "version": "0.0.1",
    "scripts": {
        "dev": "vite",
        "build": "tsc && vite build",
        "preview": "vite preview"
    },
    "devDependencies": {
        "autoprefixer": "^10.4.16",
        "daisyui": "^4.4.24",
        "postcss": "^8.4.32",
        "tailwindcss": "^3.4.0",
        "typescript": "^5.3.3",
        "vite": "^5.0.10"
    },
    "dependencies": {
        "alea": "^1.0.1",
        "simplex-noise": "^4.0.1"
    }
}

================
File: postcss.config.js
================
module.exports = {
    plugins: [require("tailwindcss"), require("autoprefixer")],
};

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
const defaultTheme = require("tailwindcss/defaultTheme");
export default {
    content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
    theme: {
        extend: {
            fontFamily: {
                sans: ["Comfortaa", ...defaultTheme.fontFamily.sans],
            },
        },
    },
    plugins: [require("daisyui")],
    daisyui: {
        themes: ["light", "dark", "cyberpunk"],
    },
};

================
File: tsconfig.json
================
{
    "compilerOptions": {
        "target": "ESNext",
        "useDefineForClassFields": true,
        "module": "ESNext",
        "lib": ["ESNext", "DOM"],
        "moduleResolution": "Node",
        "strict": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "esModuleInterop": true,
        "noEmit": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noImplicitReturns": true,
        "skipLibCheck": true
    },
    "include": ["src"]
}
